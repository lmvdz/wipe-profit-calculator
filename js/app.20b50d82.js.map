{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/components/Home.vue?f932","webpack:///./src/App.vue?69db","webpack:///./src/util/candyMachine.tsx","webpack:///./src/App.vue?f956","webpack:///./src/components/Home.vue?a6cf","webpack:///./src/composables/state.js","webpack:///./src/util/useCandyMachine.tsx","webpack:///./src/components/Home.vue","webpack:///./src/components/Home.vue?ab4a","webpack:///./src/App.vue","webpack:///./src/App.vue?8ecf","webpack:///./src/main.ts","webpack:///./src/util/index.ts"],"names":["webpackJsonpCallback","data","moduleId","chunkId","chunkIds","moreModules","executeModules","i","resolves","length","Object","prototype","hasOwnProperty","call","installedChunks","push","modules","parentJsonpFunction","shift","deferredModules","apply","checkDeferredModules","result","deferredModule","fulfilled","j","depId","splice","__webpack_require__","s","installedModules","exports","module","l","m","c","d","name","getter","o","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","p","jsonpArray","window","oldJsonpFunction","slice","CANDY_MACHINE_PROGRAM","PublicKey","SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID","TOKEN_METADATA_PROGRAM_ID","awaitTransactionSignatureConfirmation","txid","timeout","connection","commitment","queryStatus","done","status","slot","confirmations","err","subId","Promise","resolve","reject","setTimeout","console","log","onSignature","context","e","error","getSignatureStatuses","signatureStatuses","_signatureSubscriptions","removeSignatureListener","createAssociatedTokenAccountInstruction","associatedTokenAddress","payer","walletAddress","splTokenMintAddress","keys","pubkey","isSigner","isWritable","SystemProgram","programId","SYSVAR_RENT_PUBKEY","TransactionInstruction","Buffer","from","getCandyMachineState","wallet","candyMachineId","anchorWallet","publicKey","signAllTransactions","signTransaction","provider","preflightCommitment","fetchIdl","idl","program","candyMachine","id","account","fetch","state","itemsAvailable","words","itemsRedeemed","itemsRemaining","goLiveDate","toNumber","Date","Error","getMasterEdition","mint","findProgramAddress","toBuffer","getMetadata","getTokenWallet","getNFTsForOwner","ownerAddress","allTokens","getParsedTokenAccountsByOwner","tokenAccounts","index","tokenAccount","tokenAmount","parsed","info","amount","decimals","pda","getParsedAccountInfo","accountInfo","metadata","Metadata","toString","uri","dataRes","json","mintOneToken","config","treasury","Keypair","generate","token","masterEdition","getMinimumBalanceForRentExemption","span","rent","payload","accounts","mintAuthority","updateAuthority","tokenMetadataProgram","tokenProgram","systemProgram","clock","SYSVAR_CLOCK_PUBKEY","signers","instructions","createAccount","fromPubkey","newAccountPubkey","space","lamports","createInitMintInstruction","createMintToInstruction","rpc","mintNft","mintMultipleToken","quantity","signersMatrix","instructionsMatrix","instruction","render","_ctx","_cache","$props","$setup","$data","$options","_component_wallet_multi_button","_component_wallet_modal_provider","_component_home","_component_wallet_provider","wallets","default","_","_hoisted_1","_hoisted_2","_hoisted_3","_hoisted_4","_hoisted_5","style","_hoisted_6","_hoisted_7","connected","balance","nftCount","disabled","calculating","onClick","$event","calculate","output","useState","initialState","ref","setState","newState","readonly","Connection","getTokenAmountInWallet","tokenMintAddress","a","post","toBase58","headers","then","response","Math","pow","components","methods","this","setCalculating","setBalance","nfts","setNftCount","filter","nft","undefined","collection","family","calculate_profit_using_current_price","calculation","symbol","toUpperCase","denomination","least_token","most_token","current_price","profit_least","profit_most","setOutput","catch","coin_id","starting_token","staking_reward","staking_reward_weekly_interval","number_of_nfts","number_of_weeks","starting_week","errors","forEach","weekly_token_from_nfts","weekly_token_50k","least_amount_of_wipe","Number","week_counter","most_amount_of_wipe","market_data","mounted","setup","rpcHost","useWallet","__exports__","Home","WalletProvider","WalletModalProvider","WalletMultiButton","app","App","mount","SequenceType","sendTransactions","instructionSet","signersSet","sequenceType","Parallel","block","unsignedTxns","getRecentBlockhash","transaction","add","recentBlockhash","blockhash","feePayer","partialSign","map","signedTxns","pendingTxns","breakEarlyObject","breakEarly","txIds","signedTxnPromise","sendSignedTransaction","signedTransaction","StopOnFailure","all","getUnixTs","getTime","DEFAULT_TIMEOUT","rawTransaction","serialize","startTime","sendRawTransaction","skipPreflight","sleep","confirmation","simulateResult","simulateTransaction","logs","line","startsWith","JSON","stringify","_recentBlockhash","_disableBlockhashCaching","signData","serializeMessage","wireTransaction","_serialize","encodedTransaction","encoding","args","_rpcRequest","res","message","ms"],"mappings":"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","file":"js/app.20b50d82.js","sourcesContent":[" \t// install a JSONP callback for chunk loading\n \tfunction webpackJsonpCallback(data) {\n \t\tvar chunkIds = data[0];\n \t\tvar moreModules = data[1];\n \t\tvar executeModules = data[2];\n\n \t\t// add \"moreModules\" to the modules object,\n \t\t// then flag all \"chunkIds\" as loaded and fire callback\n \t\tvar moduleId, chunkId, i = 0, resolves = [];\n \t\tfor(;i < chunkIds.length; i++) {\n \t\t\tchunkId = chunkIds[i];\n \t\t\tif(Object.prototype.hasOwnProperty.call(installedChunks, chunkId) && installedChunks[chunkId]) {\n \t\t\t\tresolves.push(installedChunks[chunkId][0]);\n \t\t\t}\n \t\t\tinstalledChunks[chunkId] = 0;\n \t\t}\n \t\tfor(moduleId in moreModules) {\n \t\t\tif(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n \t\t\t\tmodules[moduleId] = moreModules[moduleId];\n \t\t\t}\n \t\t}\n \t\tif(parentJsonpFunction) parentJsonpFunction(data);\n\n \t\twhile(resolves.length) {\n \t\t\tresolves.shift()();\n \t\t}\n\n \t\t// add entry modules from loaded chunk to deferred list\n \t\tdeferredModules.push.apply(deferredModules, executeModules || []);\n\n \t\t// run deferred modules when all chunks ready\n \t\treturn checkDeferredModules();\n \t};\n \tfunction checkDeferredModules() {\n \t\tvar result;\n \t\tfor(var i = 0; i < deferredModules.length; i++) {\n \t\t\tvar deferredModule = deferredModules[i];\n \t\t\tvar fulfilled = true;\n \t\t\tfor(var j = 1; j < deferredModule.length; j++) {\n \t\t\t\tvar depId = deferredModule[j];\n \t\t\t\tif(installedChunks[depId] !== 0) fulfilled = false;\n \t\t\t}\n \t\t\tif(fulfilled) {\n \t\t\t\tdeferredModules.splice(i--, 1);\n \t\t\t\tresult = __webpack_require__(__webpack_require__.s = deferredModule[0]);\n \t\t\t}\n \t\t}\n\n \t\treturn result;\n \t}\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded and loading chunks\n \t// undefined = chunk not loaded, null = chunk preloaded/prefetched\n \t// Promise = chunk loading, 0 = chunk loaded\n \tvar installedChunks = {\n \t\t\"app\": 0\n \t};\n\n \tvar deferredModules = [];\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n \tvar jsonpArray = window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || [];\n \tvar oldJsonpFunction = jsonpArray.push.bind(jsonpArray);\n \tjsonpArray.push = webpackJsonpCallback;\n \tjsonpArray = jsonpArray.slice();\n \tfor(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);\n \tvar parentJsonpFunction = oldJsonpFunction;\n\n\n \t// add entry module to deferred list\n \tdeferredModules.push([0,\"chunk-vendors\"]);\n \t// run deferred modules when ready\n \treturn checkDeferredModules();\n","export * from \"-!../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--7-oneOf-1-0!../../node_modules/css-loader/dist/cjs.js??ref--7-oneOf-1-1!../../node_modules/vue-loader-v16/dist/stylePostLoader.js!../../node_modules/postcss-loader/src/index.js??ref--7-oneOf-1-2!../../node_modules/cache-loader/dist/cjs.js??ref--1-0!../../node_modules/vue-loader-v16/dist/index.js??ref--1-1!./Home.vue?vue&type=style&index=0&id=42f3ffc0&lang=css\"","export * from \"-!../node_modules/mini-css-extract-plugin/dist/loader.js??ref--7-oneOf-1-0!../node_modules/css-loader/dist/cjs.js??ref--7-oneOf-1-1!../node_modules/vue-loader-v16/dist/stylePostLoader.js!../node_modules/postcss-loader/src/index.js??ref--7-oneOf-1-2!../node_modules/cache-loader/dist/cjs.js??ref--1-0!../node_modules/vue-loader-v16/dist/index.js??ref--1-1!./App.vue?vue&type=style&index=0&id=bf7dde22&lang=css\"","import * as anchor from \"@project-serum/anchor\";\r\nimport { programs } from \"@metaplex/js\";\r\n\r\nimport { MintLayout, TOKEN_PROGRAM_ID, Token } from \"@solana/spl-token\";\r\nimport { sendTransactions, sleep } from \".\";\r\nimport { fetchHashTable } from \"./useHashTable\";\r\n\r\nimport { Wallet } from \"@project-serum/anchor/src/provider\";\r\n\r\nimport { Ref } from \"@vue/reactivity\";\r\nimport { PublicKey, SlotChangeCallback } from \"@solana/web3.js\";\r\nimport { WalletStore } from \"@solana/wallet-adapter-vue\";\r\n\r\nexport const CANDY_MACHINE_PROGRAM = new anchor.web3.PublicKey(\r\n    \"cndyAnrLdpjq1Ssp1z8xxDsB8dxe7u4HL5Nxi2K5WXZ\"\r\n);\r\n\r\nconst SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID = new anchor.web3.PublicKey(\r\n    \"ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL\"\r\n);\r\n\r\nconst TOKEN_METADATA_PROGRAM_ID = new anchor.web3.PublicKey(\r\n    \"metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s\"\r\n);\r\n\r\nexport interface CandyMachine {\r\n    id: anchor.web3.PublicKey;\r\n    connection: anchor.web3.Connection;\r\n    program: anchor.Program;\r\n}\r\n\r\ninterface CandyMachineState {\r\n    candyMachine: any;\r\n    itemsAvailable: number;\r\n    itemsRedeemed: number;\r\n    itemsRemaining: number;\r\n    goLiveDate: Date;\r\n}\r\n\r\nexport const awaitTransactionSignatureConfirmation = async (\r\n    txid: anchor.web3.TransactionSignature,\r\n    timeout: number,\r\n    connection: anchor.web3.Connection,\r\n    commitment: anchor.web3.Commitment = \"recent\",\r\n    queryStatus = false\r\n): Promise<anchor.web3.SignatureStatus | null | void> => {\r\n    let done = false;\r\n    let status: anchor.web3.SignatureStatus | null | void = {\r\n        slot: 0,\r\n        confirmations: 0,\r\n        err: null,\r\n    };\r\n    let subId = 0;\r\n    status = await new Promise( (resolve, reject) => {\r\n        setTimeout(() => {\r\n            if (done) {\r\n                return;\r\n            }\r\n            done = true;\r\n            console.log(\"Rejecting for timeout...\");\r\n            reject({ timeout: true });\r\n        }, timeout);\r\n        try {\r\n            subId = connection.onSignature(\r\n                txid,\r\n                (result: any, context: any) => {\r\n                    done = true;\r\n                    status = {\r\n                        err: result.err,\r\n                        slot: context.slot,\r\n                        confirmations: 0,\r\n                    };\r\n                    if (result.err) {\r\n                        console.log(\"Rejected via websocket\", result.err);\r\n                        reject(status);\r\n                    } else {\r\n                        console.log(\"Resolved via websocket\", result);\r\n                        resolve(status);\r\n                    }\r\n                },\r\n                commitment\r\n            );\r\n        } catch (e) {\r\n            done = true;\r\n            console.error(\"WS error in setup\", txid, e);\r\n        }\r\n        while (!done && queryStatus) {\r\n            (async () => {\r\n                try {\r\n                    const signatureStatuses =\r\n                        await connection.getSignatureStatuses([txid]);\r\n                    status = signatureStatuses && signatureStatuses.value[0];\r\n                    if (!done) {\r\n                        if (!status) {\r\n                            console.log(\"REST null result for\", txid, status);\r\n                        } else if (status.err) {\r\n                            console.log(\"REST error for\", txid, status);\r\n                            done = true;\r\n                            reject(status.err);\r\n                        } else if (!status.confirmations) {\r\n                            console.log(\r\n                                \"REST no confirmations for\",\r\n                                txid,\r\n                                status\r\n                            );\r\n                        } else {\r\n                            console.log(\"REST confirmation for\", txid, status);\r\n                            done = true;\r\n                            resolve(status);\r\n                        }\r\n                    }\r\n                } catch (e) {\r\n                    if (!done) {\r\n                        console.log(\"REST connection error: txid\", txid, e);\r\n                    }\r\n                }\r\n            })();\r\n            sleep(2000);\r\n        }\r\n    });\r\n\r\n    if ((connection as any)._signatureSubscriptions[subId]) {\r\n        connection.removeSignatureListener(subId);\r\n    }\r\n    done = true;\r\n    console.log(\"Returning status\", status);\r\n    return status;\r\n};\r\n\r\nconst createAssociatedTokenAccountInstruction = (\r\n    associatedTokenAddress: anchor.web3.PublicKey,\r\n    payer: anchor.web3.PublicKey,\r\n    walletAddress: anchor.web3.PublicKey,\r\n    splTokenMintAddress: anchor.web3.PublicKey\r\n) => {\r\n    const keys = [\r\n        { pubkey: payer, isSigner: true, isWritable: true },\r\n        { pubkey: associatedTokenAddress, isSigner: false, isWritable: true },\r\n        { pubkey: walletAddress, isSigner: false, isWritable: false },\r\n        { pubkey: splTokenMintAddress, isSigner: false, isWritable: false },\r\n        {\r\n            pubkey: anchor.web3.SystemProgram.programId,\r\n            isSigner: false,\r\n            isWritable: false,\r\n        },\r\n        { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },\r\n        {\r\n            pubkey: anchor.web3.SYSVAR_RENT_PUBKEY,\r\n            isSigner: false,\r\n            isWritable: false,\r\n        },\r\n    ];\r\n    return new anchor.web3.TransactionInstruction({\r\n        keys,\r\n        programId: SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\r\n        data: Buffer.from([]),\r\n    });\r\n};\r\n\r\nexport const getCandyMachineState = async (\r\n    wallet: WalletStore,\r\n    candyMachineId: anchor.web3.PublicKey,\r\n    connection: anchor.web3.Connection\r\n): Promise<CandyMachineState> => {\r\n\r\n    const anchorWallet = {\r\n        publicKey: wallet.publicKey.value,\r\n        signAllTransactions: wallet.signAllTransactions.value,\r\n        signTransaction: wallet.signTransaction.value\r\n    } as Wallet;\r\n\r\n    const provider = new anchor.Provider(connection, anchorWallet, {\r\n        preflightCommitment: \"recent\",\r\n    });\r\n    const idl = await anchor.Program.fetchIdl(CANDY_MACHINE_PROGRAM, provider);\r\n\r\n    if (idl) {\r\n        const program = new anchor.Program(\r\n            idl,\r\n            CANDY_MACHINE_PROGRAM,\r\n            provider\r\n        );\r\n        const candyMachine = {\r\n            id: candyMachineId,\r\n            connection,\r\n            program,\r\n        };\r\n        const state: any = await program.account.candyMachine.fetch(\r\n            candyMachineId\r\n        );\r\n        const itemsAvailable = state.data.itemsAvailable.words[0];\r\n        const itemsRedeemed = state.itemsRedeemed.words[0];\r\n        const itemsRemaining = itemsAvailable - itemsRedeemed;\r\n\r\n        let goLiveDate = state.data.goLiveDate.toNumber();\r\n        goLiveDate = new Date(goLiveDate * 1000);\r\n\r\n        return {\r\n            candyMachine,\r\n            itemsAvailable,\r\n            itemsRedeemed,\r\n            itemsRemaining,\r\n            goLiveDate,\r\n        };\r\n    } else {\r\n        throw new Error(\r\n            `Fetching idl returned null: check CANDY_MACHINE_PROGRAM`\r\n        );\r\n    }\r\n};\r\n\r\nconst getMasterEdition = async (\r\n    mint: anchor.web3.PublicKey\r\n): Promise<anchor.web3.PublicKey> => {\r\n    return (\r\n        await anchor.web3.PublicKey.findProgramAddress(\r\n            [\r\n                Buffer.from(\"metadata\"),\r\n                TOKEN_METADATA_PROGRAM_ID.toBuffer(),\r\n                mint.toBuffer(),\r\n                Buffer.from(\"edition\"),\r\n            ],\r\n            TOKEN_METADATA_PROGRAM_ID\r\n        )\r\n    )[0];\r\n};\r\n\r\nconst getMetadata = async (\r\n    mint: anchor.web3.PublicKey\r\n): Promise<anchor.web3.PublicKey> => {\r\n    return (\r\n        await anchor.web3.PublicKey.findProgramAddress(\r\n            [\r\n                Buffer.from(\"metadata\"),\r\n                TOKEN_METADATA_PROGRAM_ID.toBuffer(),\r\n                mint.toBuffer(),\r\n            ],\r\n            TOKEN_METADATA_PROGRAM_ID\r\n        )\r\n    )[0];\r\n};\r\n\r\nconst getTokenWallet = async (\r\n    wallet: anchor.web3.PublicKey,\r\n    mint: anchor.web3.PublicKey\r\n) => {\r\n    return (\r\n        await anchor.web3.PublicKey.findProgramAddress(\r\n            [wallet.toBuffer(), TOKEN_PROGRAM_ID.toBuffer(), mint.toBuffer()],\r\n            SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID\r\n        )\r\n    )[0];\r\n};\r\n\r\nexport async function getNFTsForOwner(\r\n    connection: anchor.web3.Connection,\r\n    ownerAddress: anchor.web3.PublicKey\r\n) {\r\n    // const allMintsCandyMachine = await fetchHashTable(\r\n    //     // process.env.VUE_APP_PUBLIC_CANDY_MACHINE_ID!\r\n    //     '2Qv8NbACuthF8ja8RxDY2ZXCvTTv89aAWVHSCFDo4yM9'\r\n    // );\r\n    // console.log(allMintsCandyMachine);\r\n\r\n    \r\n    const allTokens = [];\r\n    const tokenAccounts = await connection.getParsedTokenAccountsByOwner(\r\n        ownerAddress,\r\n        {\r\n            programId: TOKEN_PROGRAM_ID,\r\n        }\r\n    );\r\n    // console.log(tokenAccounts)\r\n\r\n    for (let index = 0; index < tokenAccounts.value.length; index++) {\r\n        const tokenAccount = tokenAccounts.value[index];\r\n        const tokenAmount = tokenAccount.account.data.parsed.info.tokenAmount;\r\n\r\n        if (\r\n            tokenAmount.amount == \"1\" &&\r\n            tokenAmount.decimals == \"0\" \r\n            // &&\r\n            // allMintsCandyMachine.includes(\r\n            //     tokenAccount.account.data.parsed.info.mint\r\n            // )\r\n        ) {\r\n            const [pda] = await anchor.web3.PublicKey.findProgramAddress(\r\n                [\r\n                    Buffer.from(\"metadata\"),\r\n                    TOKEN_METADATA_PROGRAM_ID.toBuffer(),\r\n                    new anchor.web3.PublicKey(\r\n                        tokenAccount.account.data.parsed.info.mint\r\n                    ).toBuffer(),\r\n                ],\r\n                TOKEN_METADATA_PROGRAM_ID\r\n            );\r\n            const accountInfo: any = await connection.getParsedAccountInfo(pda);\r\n\r\n            const metadata: any = new programs.metadata.Metadata(\r\n                ownerAddress.toString(),\r\n                accountInfo.value\r\n            );\r\n            const dataRes = await fetch(metadata.data.data.uri);\r\n            if (dataRes.status === 200) {\r\n                allTokens.push(await dataRes.json());\r\n            }\r\n        }\r\n    }\r\n\r\n    return allTokens;\r\n}\r\n\r\nexport const mintOneToken = async (\r\n    candyMachine: CandyMachine,\r\n    config: anchor.web3.PublicKey, // feels like this should be part of candyMachine?\r\n    payer: anchor.web3.PublicKey,\r\n    treasury: anchor.web3.PublicKey\r\n): Promise<string> => {\r\n\r\n    const mint = anchor.web3.Keypair.generate();\r\n    const token = await getTokenWallet(payer, mint.publicKey);\r\n    const { connection, program } = candyMachine;\r\n    const metadata = await getMetadata(mint.publicKey);\r\n    const masterEdition = await getMasterEdition(mint.publicKey);\r\n\r\n    const rent = await connection.getMinimumBalanceForRentExemption(\r\n        MintLayout.span\r\n    );\r\n    const payload = {\r\n        accounts: {\r\n            config,\r\n            candyMachine: candyMachine.id,\r\n            payer: payer,\r\n            wallet: treasury,\r\n            mint: mint.publicKey,\r\n            metadata,\r\n            masterEdition,\r\n            mintAuthority: payer,\r\n            updateAuthority: payer,\r\n            tokenMetadataProgram: TOKEN_METADATA_PROGRAM_ID,\r\n            tokenProgram: TOKEN_PROGRAM_ID,\r\n            systemProgram: anchor.web3.SystemProgram.programId,\r\n            rent: anchor.web3.SYSVAR_RENT_PUBKEY,\r\n            clock: anchor.web3.SYSVAR_CLOCK_PUBKEY,\r\n        },\r\n        signers: [mint],\r\n        instructions: [\r\n            anchor.web3.SystemProgram.createAccount({\r\n                fromPubkey: payer,\r\n                newAccountPubkey: mint.publicKey,\r\n                space: MintLayout.span,\r\n                lamports: rent,\r\n                programId: TOKEN_PROGRAM_ID,\r\n            }),\r\n            Token.createInitMintInstruction(\r\n                TOKEN_PROGRAM_ID,\r\n                mint.publicKey,\r\n                0,\r\n                payer,\r\n                payer\r\n            ),\r\n            createAssociatedTokenAccountInstruction(\r\n                token,\r\n                payer,\r\n                payer,\r\n                mint.publicKey\r\n            ),\r\n            Token.createMintToInstruction(\r\n                TOKEN_PROGRAM_ID,\r\n                mint.publicKey,\r\n                token,\r\n                payer,\r\n                [],\r\n                1\r\n            ),\r\n        ],\r\n    };\r\n    return await program.rpc.mintNft(payload); \r\n};\r\n\r\nexport const mintMultipleToken = async (\r\n    candyMachine: CandyMachine,\r\n    config: anchor.web3.PublicKey,\r\n    payer: anchor.web3.PublicKey,\r\n    treasury: anchor.web3.PublicKey,\r\n    quantity: number\r\n) => {\r\n    const signersMatrix = [];\r\n    const instructionsMatrix = [];\r\n\r\n    for (let index = 0; index < quantity; index++) {\r\n        const mint = anchor.web3.Keypair.generate();\r\n        const token = await getTokenWallet(payer, mint.publicKey);\r\n        const { connection } = candyMachine;\r\n        const rent = await connection.getMinimumBalanceForRentExemption(\r\n            MintLayout.span\r\n        );\r\n        const instructions = [\r\n            anchor.web3.SystemProgram.createAccount({\r\n                fromPubkey: payer,\r\n                newAccountPubkey: mint.publicKey,\r\n                space: MintLayout.span,\r\n                lamports: rent,\r\n                programId: TOKEN_PROGRAM_ID,\r\n            }),\r\n            Token.createInitMintInstruction(\r\n                TOKEN_PROGRAM_ID,\r\n                mint.publicKey,\r\n                0,\r\n                payer,\r\n                payer\r\n            ),\r\n            createAssociatedTokenAccountInstruction(\r\n                token,\r\n                payer,\r\n                payer,\r\n                mint.publicKey\r\n            ),\r\n            Token.createMintToInstruction(\r\n                TOKEN_PROGRAM_ID,\r\n                mint.publicKey,\r\n                token,\r\n                payer,\r\n                [],\r\n                1\r\n            ),\r\n        ];\r\n        const masterEdition = await getMasterEdition(mint.publicKey);\r\n        const metadata = await getMetadata(mint.publicKey);\r\n\r\n        instructions.push(\r\n            await candyMachine.program.instruction.mintNft({\r\n                accounts: {\r\n                    config,\r\n                    candyMachine: candyMachine.id,\r\n                    payer: payer,\r\n                    wallet: treasury,\r\n                    mint: mint.publicKey,\r\n                    metadata,\r\n                    masterEdition,\r\n                    mintAuthority: payer,\r\n                    updateAuthority: payer,\r\n                    tokenMetadataProgram: TOKEN_METADATA_PROGRAM_ID,\r\n                    tokenProgram: TOKEN_PROGRAM_ID,\r\n                    systemProgram: anchor.web3.SystemProgram.programId,\r\n                    rent: anchor.web3.SYSVAR_RENT_PUBKEY,\r\n                    clock: anchor.web3.SYSVAR_CLOCK_PUBKEY,\r\n                },\r\n            })\r\n        );\r\n        const signers: anchor.web3.Keypair[] = [mint];\r\n\r\n        signersMatrix.push(signers);\r\n        instructionsMatrix.push(instructions);\r\n    }\r\n\r\n    return await sendTransactions(\r\n        candyMachine.program.provider.connection,\r\n        candyMachine.program.provider.wallet,\r\n        instructionsMatrix,\r\n        signersMatrix\r\n    );\r\n};\r\n\r\nexport const shortenAddress = (address: string, chars = 4): string => {\r\n    return `${address.slice(0, chars)}...${address.slice(-chars)}`;\r\n};","import { resolveComponent as _resolveComponent, createVNode as _createVNode, withCtx as _withCtx, createElementVNode as _createElementVNode, openBlock as _openBlock, createBlock as _createBlock } from \"vue\"\n\nexport function render(_ctx: any,_cache: any,$props: any,$setup: any,$data: any,$options: any) {\n  const _component_wallet_multi_button = _resolveComponent(\"wallet-multi-button\")!\n  const _component_wallet_modal_provider = _resolveComponent(\"wallet-modal-provider\")!\n  const _component_home = _resolveComponent(\"home\")!\n  const _component_wallet_provider = _resolveComponent(\"wallet-provider\")!\n\n  return (_openBlock(), _createBlock(_component_wallet_provider, {\n    wallets: _ctx.wallets,\n    \"auto-connect\": \"\"\n  }, {\n    default: _withCtx(() => [\n      _createElementVNode(\"div\", null, [\n        _createElementVNode(\"div\", null, [\n          _createVNode(_component_wallet_modal_provider, null, {\n            default: _withCtx(() => [\n              _createVNode(_component_wallet_multi_button)\n            ]),\n            _: 1\n          })\n        ]),\n        _createVNode(_component_home)\n      ])\n    ]),\n    _: 1\n  }, 8, [\"wallets\"]))\n}","import { createElementVNode as _createElementVNode, openBlock as _openBlock, createElementBlock as _createElementBlock, createCommentVNode as _createCommentVNode, toDisplayString as _toDisplayString, Transition as _Transition, withCtx as _withCtx, createVNode as _createVNode } from \"vue\"\n\nconst _hoisted_1 = /*#__PURE__*/_createElementVNode(\"p\", null, \"WipeMyAss - Profit Calculator\", -1)\nconst _hoisted_2 = { key: 0 }\nconst _hoisted_3 = { key: 0 }\nconst _hoisted_4 = [\"disabled\"]\nconst _hoisted_5 = {\n  key: 1,\n  style: {\"display\":\"inline-block\"}\n}\nconst _hoisted_6 = [\"disabled\"]\nconst _hoisted_7 = { key: 0 }\n\nexport function render(_ctx: any,_cache: any,$props: any,$setup: any,$data: any,$options: any) {\n  return (_openBlock(), _createElementBlock(\"div\", null, [\n    _hoisted_1,\n    _createVNode(_Transition, { name: \"fade\" }, {\n      default: _withCtx(() => [\n        (_ctx.connected)\n          ? (_openBlock(), _createElementBlock(\"div\", _hoisted_2, [\n              ((_ctx.balance === 0 || _ctx.nftCount === 0))\n                ? (_openBlock(), _createElementBlock(\"div\", _hoisted_3, [\n                    _createElementVNode(\"button\", {\n                      disabled: _ctx.calculating,\n                      onClick: _cache[0] || (_cache[0] = ($event: any) => (_ctx.calculate()))\n                    }, \"Calculate\", 8, _hoisted_4)\n                  ]))\n                : (_openBlock(), _createElementBlock(\"div\", _hoisted_5, [\n                    _createElementVNode(\"button\", {\n                      disabled: _ctx.calculating,\n                      onClick: _cache[1] || (_cache[1] = ($event: any) => (_ctx.calculate()))\n                    }, \"Calculate\", 8, _hoisted_6),\n                    _createElementVNode(\"p\", null, \"$WIPE Balance: \" + _toDisplayString(_ctx.balance), 1),\n                    _createElementVNode(\"p\", null, \"NFT Count: \" + _toDisplayString(_ctx.nftCount), 1),\n                    _createElementVNode(\"p\", null, _toDisplayString(_ctx.output[1]) + \" \" + _toDisplayString(_ctx.output[4]), 1),\n                    (_ctx.output.length > 0)\n                      ? (_openBlock(), _createElementBlock(\"table\", _hoisted_7, [\n                          _createElementVNode(\"tr\", null, [\n                            _createElementVNode(\"th\", null, _toDisplayString(_ctx.output[0]), 1),\n                            _createElementVNode(\"th\", null, _toDisplayString(_ctx.output[2]), 1)\n                          ]),\n                          _createElementVNode(\"tr\", null, [\n                            _createElementVNode(\"td\", null, _toDisplayString(_ctx.output[3]), 1),\n                            _createElementVNode(\"td\", null, _toDisplayString(_ctx.output[5]), 1)\n                          ])\n                        ]))\n                      : _createCommentVNode(\"\", true)\n                  ]))\n            ]))\n          : _createCommentVNode(\"\", true)\n      ]),\n      _: 1\n    })\n  ]))\n}","// src/composables/state.js\r\nimport { readonly, ref } from 'vue';\r\n\r\nexport default function useState(initialState) {\r\n  const state = ref(initialState);\r\n  const setState = (newState) => {\r\n    state.value = newState;\r\n  };\r\n  \r\n  return [readonly(state), setState];\r\n}","import useState from '../composables/state.js'\r\nimport * as anchor from \"@project-serum/anchor\";\r\nimport { Wallet } from \"@project-serum/anchor/src/provider\"\r\nimport {\r\n    awaitTransactionSignatureConfirmation,\r\n    CandyMachine,\r\n    getCandyMachineState,\r\n    mintMultipleToken,\r\n    mintOneToken,\r\n} from \"./candyMachine\";\r\nimport { useWallet, useAnchorWallet, WalletStore } from \"@solana/wallet-adapter-vue\";\r\nimport { LAMPORTS_PER_SOL, PublicKey } from \"@solana/web3.js\";\r\nimport { sleep } from '.';\r\nimport { SignatureStatus } from '@solana/web3.js';\r\n\r\nimport { createToast } from 'mosha-vue-toastify';\r\nimport axois from 'axios'\r\n\r\n\r\nconst MINT_PRICE_SOL = 1;\r\n\r\nconst treasury = new anchor.web3.PublicKey(\r\n    process.env.VUE_APP_PUBLIC_TREASURY_ADDRESS!\r\n);\r\n\r\nconst config = new anchor.web3.PublicKey(\r\n    process.env.VUE_APP_PUBLIC_CANDY_MACHINE_CONFIG!\r\n);\r\n\r\nconst candyMachineId = new anchor.web3.PublicKey(\r\n    process.env.VUE_APP_PUBLIC_CANDY_MACHINE_ID!\r\n);\r\n\r\nconst rpcHost = process.env.VUE_APP_PUBLIC_SOLANA_RPC_HOST!;\r\nconst connection = new anchor.web3.Connection(rpcHost);\r\n\r\nconst txTimeout = 30000;\r\n\r\nconst [balance, setBalance] = useState(0);\r\nconst [nftsData, setNftsData] = useState(\r\n    ({\r\n        itemsRemaining: 0,\r\n        itemsRedeemed: 0,\r\n        itemsAvailable: 0,\r\n    } as any)\r\n);\r\nconst [isMinting, setIsMinting] = useState(false);\r\nconst [isSoldOut, setIsSoldOut] = useState(false);\r\n\r\nexport function getMintStartDate(wallet: WalletStore) : Promise<Date> {\r\n    return new Promise(function(resolve, reject) {\r\n        getCandyMachineState(\r\n            wallet,\r\n            candyMachineId,\r\n            connection\r\n        ).then(({ goLiveDate }) => {\r\n            resolve(goLiveDate);\r\n        }).catch(error => {\r\n            reject(error);\r\n        })\r\n    })\r\n}\r\nexport function getNFTData(wallet: WalletStore) : Promise<{itemsRemaining:number, itemsRedeemed:number, itemsAvailable:number}> {\r\n    return new Promise(function(resolve, reject) {\r\n        getCandyMachineState(\r\n            wallet,\r\n            candyMachineId,\r\n            connection\r\n        ).then(({ itemsRedeemed, itemsAvailable, itemsRemaining }) => {\r\n            resolve({ itemsRemaining, itemsRedeemed, itemsAvailable });\r\n        }).catch(error => {\r\n            reject(error);\r\n        })\r\n    })\r\n}\r\nexport function getIsSoldOut(wallet: WalletStore) : Promise<boolean> {\r\n    return new Promise(function(resolve, reject) {\r\n        getCandyMachineState(\r\n            wallet,\r\n            candyMachineId,\r\n            connection\r\n        ).then(({ itemsRemaining }) => {\r\n            resolve(itemsRemaining === 0);\r\n        }).catch(error => {\r\n            reject(error);\r\n        })\r\n    })\r\n}\r\nexport function getIsMinting() : boolean {\r\n    return isMinting;\r\n}\r\nexport function getBalance(wallet: WalletStore) : Promise<number> {\r\n    return new Promise(function(resolve, reject) {\r\n        if(wallet.publicKey.value)\r\n            connection.getBalance(wallet.publicKey.value).then(bal => {\r\n                resolve(bal / LAMPORTS_PER_SOL);\r\n            }).catch(error => {\r\n                reject(error);\r\n            })\r\n        else {\r\n            resolve(0)\r\n        }\r\n    }) \r\n}\r\nexport function getTokenAmountInWallet(wallet: WalletStore, tokenMintAddress: string | PublicKey) : Promise<number> {\r\n    return new Promise(function(resolve, reject) {\r\n        if(wallet.publicKey.value) {\r\n            axois.post('https://api.mainnet-beta.solana.com',  {\r\n                \"jsonrpc\": \"2.0\",\r\n                \"id\": 1,\r\n                \"method\": \"getTokenAccountsByOwner\",\r\n                \"params\": [\r\n                    wallet.publicKey.value.toBase58(),\r\n                {\r\n                    \"mint\": tokenMintAddress\r\n                },\r\n                {\r\n                    \"encoding\": \"jsonParsed\"\r\n                }\r\n                ]\r\n            }, { headers: {\r\n                \"Content-Type\": \"application/json\"\r\n            }}).then(response => {\r\n                const tokenAmount = response.data.result.value[0].account.data.parsed.info.tokenAmount;\r\n                const amount =  (tokenAmount.amount / (Math.pow(10, tokenAmount.decimals)))\r\n                resolve(amount);\r\n            })\r\n        } else {\r\n            resolve(-1)\r\n        }\r\n    })\r\n}\r\nexport function useCandyMachine(wallet: WalletStore) {\r\n    const startMint = async () => {\r\n        try {\r\n            const { candyMachine } =\r\n            await getCandyMachineState(\r\n                wallet,\r\n                candyMachineId,\r\n                connection\r\n            );\r\n            \r\n            if (wallet.connected && candyMachine.program && wallet.publicKey.value) {\r\n                const mintTxId = await mintOneToken(\r\n                    candyMachine,\r\n                    config,\r\n                    wallet.publicKey.value,\r\n                    treasury\r\n                );\r\n                const status = await awaitTransactionSignatureConfirmation(\r\n                    mintTxId,\r\n                    txTimeout,\r\n                    connection,\r\n                    \"singleGossip\",\r\n                    false\r\n                );\r\n                (async (status: SignatureStatus) => {\r\n                    if (!status?.err) {\r\n                        createToast(\r\n                            \"Congratulations! Mint succeeded! Check your wallet :)\", {\r\n                                type: 'success', timeout: 6000, position: 'bottom-center'\r\n                            }\r\n                        );\r\n                    } else {\r\n                        createToast(\"Mint failed! Please try again!\", {\r\n                            type: 'danger', timeout: 6000, position: 'bottom-center'\r\n                        });\r\n                    }\r\n                })(status as SignatureStatus)\r\n                \r\n            }\r\n        } catch (error: any) {\r\n            let message = error.message || \"Minting failed! Please try again!\";\r\n            if (!error.message) {\r\n                if (error.message.indexOf(\"0x138\")) {\r\n                    message = \"0x138\"\r\n                } else if (error.message.indexOf(\"0x137\")) {\r\n                    message = `SOLD OUT!`;\r\n                } else if (error.message.indexOf(\"0x135\")) {\r\n                    message = `Insufficient funds to mint. Please fund your wallet.`;\r\n                }\r\n            } else {\r\n                if (error.code === 311) {\r\n                    message = `SOLD OUT!`;\r\n                    setIsSoldOut(true);\r\n                } else if (error.code === 312) {\r\n                    message = `Minting period hasn't started yet.`;\r\n                }\r\n            }\r\n            createToast(message);\r\n        } finally {\r\n            if (wallet.publicKey.value) {\r\n                const balance = await connection.getBalance(wallet.publicKey.value);\r\n                setBalance(balance / LAMPORTS_PER_SOL);\r\n            }\r\n            setIsMinting(false);\r\n        }\r\n    };\r\n\r\n    const startMintMultiple = async (quantity: number) => {\r\n        try {\r\n            const { candyMachine } =\r\n            await getCandyMachineState(\r\n                wallet,\r\n                candyMachineId,\r\n                connection\r\n            );\r\n            setIsMinting(true);\r\n            if (wallet.connected && candyMachine.program && wallet.publicKey.value) {\r\n                const oldBalance =\r\n                    (await connection.getBalance(wallet.publicKey.value)) /\r\n                    LAMPORTS_PER_SOL;\r\n                const futureBalance = oldBalance - MINT_PRICE_SOL * quantity;\r\n\r\n                const signedTransactions: any = await mintMultipleToken(\r\n                    candyMachine.value,\r\n                    config,\r\n                    wallet.publicKey.value,\r\n                    treasury,\r\n                    quantity\r\n                );\r\n\r\n                const promiseArray = [];\r\n\r\n                for (\r\n                    let index = 0;\r\n                    index < signedTransactions.length;\r\n                    index++\r\n                ) {\r\n                    const tx = signedTransactions[index];\r\n                    promiseArray.push(\r\n                        awaitTransactionSignatureConfirmation(\r\n                            tx,\r\n                            txTimeout,\r\n                            connection,\r\n                            \"singleGossip\",\r\n                            true\r\n                        )\r\n                    );\r\n                }\r\n\r\n                const allTransactionsResult = await Promise.all(promiseArray);\r\n                let totalSuccess = 0;\r\n                let totalFailure = 0;\r\n\r\n                for (\r\n                    let index = 0;\r\n                    index < allTransactionsResult.length;\r\n                    index++\r\n                ) {\r\n                    const transactionStatus = allTransactionsResult[index];\r\n                    (async (transactionStatus: SignatureStatus) => {\r\n                        if (!transactionStatus?.err) {\r\n                            totalSuccess += 1;\r\n                        } else {\r\n                            totalFailure += 1;\r\n                        }\r\n                    })(transactionStatus as SignatureStatus)\r\n                    \r\n                }\r\n\r\n                let newBalance =\r\n                    (await connection.getBalance(wallet.publicKey.value)) /\r\n                    LAMPORTS_PER_SOL;\r\n\r\n                while (newBalance > futureBalance) {\r\n                    await sleep(1000);\r\n                    newBalance =\r\n                        (await connection.getBalance(wallet.publicKey.value)) /\r\n                        LAMPORTS_PER_SOL;\r\n                }\r\n\r\n                if (totalSuccess) {\r\n                    createToast(`Congratulations! ${totalSuccess} mints succeeded! Your NFT's should appear in your wallet soon :)`,\r\n                        { type: 'success', timeout: 6000, position: \"bottom-center\" }\r\n                    );\r\n                }\r\n\r\n                if (totalFailure) {\r\n                    createToast(`Some mints failed! ${totalFailure} mints failed! Check your wallet :(`,\r\n                        { type: 'danger', timeout: 6000, position: \"bottom-center\" }\r\n                    );\r\n                }\r\n            }\r\n        } catch (error: any) {\r\n            let message = error.message || \"Minting failed! Please try again!\";\r\n            if (!error.message) {\r\n                if (error.message.indexOf(\"0x138\")) {\r\n                    message = \"0x138\"\r\n                } else if (error.message.indexOf(\"0x137\")) {\r\n                    message = `SOLD OUT!`;\r\n                } else if (error.message.indexOf(\"0x135\")) {\r\n                    message = `Insufficient funds to mint. Please fund your wallet.`;\r\n                }\r\n            } else {\r\n                if (error.code === 311) {\r\n                    message = `SOLD OUT!`;\r\n                    setIsSoldOut(true);\r\n                } else if (error.code === 312) {\r\n                    message = `Minting period hasn't started yet.`;\r\n                }\r\n            }\r\n            console.error(message);\r\n        } finally {\r\n            if (wallet.publicKey.value) {\r\n                const balance = await connection.getBalance(wallet.publicKey.value);\r\n                setBalance(balance / LAMPORTS_PER_SOL);\r\n            }\r\n            setIsMinting(false);\r\n        }\r\n    };\r\n\r\n    return {\r\n        startMint,\r\n        startMintMultiple,\r\n    };\r\n}","\r\nimport { useWallet } from \"@solana/wallet-adapter-vue\";\r\nimport {\r\n    // useCandyMachine, getBalance, getIsMinting, getIsSoldOut, getMintStartDate, getNFTData, \r\n    getTokenAmountInWallet } from \"../util/useCandyMachine\";\r\n// import useWalletNfts from \"../util/useWalletNFTs\";\r\nimport { getNFTsForOwner } from \"../util/candyMachine\";\r\nimport useState from '../composables/state.js';\r\n// import AnNFT from './AnNFT.vue'\r\n\r\nimport { defineComponent } from 'vue';\r\nimport * as anchor from '@project-serum/anchor'\r\nimport axios from \"axios\";\r\nexport default defineComponent({\r\n    name: \"Home\",\r\n    components: {\r\n        // AnNFT\r\n    },\r\n    methods: {\r\n        calculate() {\r\n            this.setCalculating(true)\r\n            getTokenAmountInWallet(this.wallet, '9ae76zqD3cgzR9gvf5Thc2NN3ACF7rqqnrLqxNzgcre6').then(amount => {\r\n                this.setBalance(amount);\r\n            })\r\n            if (this.wallet.publicKey.value) {\r\n                getNFTsForOwner(this.connection, this.wallet.publicKey.value).then(nfts => {\r\n                    this.setNftCount(nfts.filter(nft => {\r\n                        if (nft.collection !== undefined)\r\n                            return nft.collection.name === \"WipeMyAss\" && nft.collection.family === \"WipeMyAss\"\r\n                        else\r\n                            return false\r\n                    }).length)\r\n                    this.calculate_profit_using_current_price('wipemyass', this.balance, 10, 1, this.nftCount, 25, 2, 'usd').then((calculation: any) => {\r\n                        let output = []\r\n                        output.push(`Total $${calculation.symbol.toUpperCase()} (min - max)`)\r\n                        output.push(`Price (${calculation.denomination.toUpperCase()})`)\r\n                        output.push(`Total ${calculation.denomination.toUpperCase()} (min - max)`)\r\n                        output.push(`${calculation.least_token} - ${calculation.most_token}`)\r\n                        output.push(`$ ${calculation.current_price}`)\r\n                        output.push(`$ ${calculation.profit_least} - ${calculation.profit_most}`)\r\n                        this.setOutput(output);\r\n                        this.setCalculating(false)\r\n                    }).catch(error => {\r\n                        this.setOutput([error]);\r\n                        this.setCalculating(false)\r\n                    })\r\n                })\r\n            }\r\n        },\r\n        calculate_profit_using_current_price(coin_id = 'wipemyass', starting_token = 30895, staking_reward = 1.1, staking_reward_weekly_interval = 1, number_of_nfts = 25, number_of_weeks = 25, starting_week = 1, denomination = 'usd') {\r\n                return new Promise(function(resolve, reject) {\r\n                    let errors = []\r\n                    if (starting_token < -1) {\r\n                        errors.push('starting_token has to be greater than or equal to zero.')\r\n                    }\r\n                    if (number_of_nfts > 3000 || number_of_nfts < 0){\r\n                        errors.push('number_of_nfts has to be greater than or equal to zero and less than three thousand.')\r\n                    }\r\n                    if (number_of_weeks > 25 || number_of_weeks < 1) {\r\n                        errors.push('number_of_weeks has to be between 1 and 25 (inclusive).');\r\n                    }\r\n                    if (starting_week > 25 || starting_week < 1) {\r\n                        errors.push('starting_week has to be between 1 and 25 (inclusive).')\r\n                    }\r\n                    if (errors.length > 0) {\r\n                        errors.forEach(error => {\r\n                            console.error(error);\r\n                        })\r\n                        reject(new Error('Failed to calculate the profit, check your parameters'));\r\n                    }\r\n                    \r\n                    const weekly_token_from_nfts = () => {\r\n                        return 3000 * number_of_nfts\r\n                    }\r\n\r\n                    const weekly_token_50k = () => {\r\n                        return 2000\r\n                    }\r\n                    \r\n                    let least_amount_of_wipe = Number(0 + starting_token);\r\n                    for(let week_counter = starting_week; week_counter <= number_of_weeks; week_counter++) {\r\n                        if (week_counter % staking_reward_weekly_interval === 0) {\r\n                            least_amount_of_wipe *= (1 + (1 / staking_reward))\r\n                        }\r\n                        least_amount_of_wipe += weekly_token_from_nfts()\r\n                        if (least_amount_of_wipe > 50000) {\r\n                            least_amount_of_wipe += weekly_token_50k()\r\n                        }\r\n                            \r\n                    }\r\n                    let most_amount_of_wipe = Number(0 + starting_token);\r\n                    \r\n                    for(let week_counter = starting_week; week_counter <= number_of_weeks; week_counter++) {\r\n                        most_amount_of_wipe += weekly_token_from_nfts()\r\n                        \r\n                        if (most_amount_of_wipe > 50000) {\r\n                            most_amount_of_wipe += weekly_token_50k()\r\n                        }\r\n                            \r\n                        if (week_counter % staking_reward_weekly_interval === 0) {\r\n                            most_amount_of_wipe *= (1 + (1 / staking_reward))\r\n                        }\r\n                    }\r\n\r\n                    axios.get('https://api.coingecko.com/api/v3/coins/'+coin_id).then(response => {\r\n                        const current_price = response.data.market_data.current_price[denomination]\r\n                        resolve({ symbol: response.data.symbol, denomination: denomination, number_of_nfts: number_of_nfts, starting_token: starting_token, least_token: least_amount_of_wipe, most_token: most_amount_of_wipe, current_price: current_price, profit_most: Number(most_amount_of_wipe * current_price), profit_least: Number(least_amount_of_wipe * current_price), error: null});\r\n                    }).catch(error => {\r\n                        console.error(error);\r\n                        resolve({ symbol: null, denomination: denomination, number_of_nfts: number_of_nfts, starting_token: starting_token, least_token: least_amount_of_wipe, most_token: most_amount_of_wipe, current_price: null, profit_most: null, error: new Error('Failed to retrieve current_price from coingecko')})\r\n                    })\r\n                    \r\n                })\r\n                \r\n            }\r\n    },\r\n    mounted() {\r\n        setTimeout(() => {\r\n            // getTokenAmountInWallet(this.wallet, '5oX9RUTfHSCpnzv6FibTCo5vFtGSsosZwj3kfQ7wWnAM').then(amount => {\r\n            //     this.setNftCount(amount);\r\n            // })\r\n            // this.getBalance(this.wallet).then(b => {\r\n            //     this.setBalance(b);\r\n            // })\r\n        }, 2000)\r\n    },\r\n    setup() {\r\n        const rpcHost = 'https://api.mainnet-beta.solana.com';\r\n        const connection = new anchor.web3.Connection(rpcHost);\r\n        const wallet = useWallet();\r\n        // const {\r\n        //     startMint,\r\n        //     startMintMultiple,\r\n        // } = useCandyMachine(wallet);\r\n\r\n        // const [isLoading, nfts] = useWalletNfts();\r\n        // const [isMintLive, setIsMintLive] = useState(false);\r\n        // const [mintStartDate, setMintStartDate] = useState(new Date(9999,0,1))\r\n        // const [nftsData, setNftsData] = useState({})\r\n        const [balance, setBalance] = useState(0);\r\n        const [nftCount, setNftCount] = useState(0);\r\n        const [output, setOutput] = useState(['']);\r\n        const [calculating, setCalculating] = useState(false);\r\n        // const [isSoldOut, setIsSoldOut] = useState(false);\r\n\r\n        // getMintStartDate(wallet).then(startDate => {\r\n        //     if (new Date(startDate).getTime() < Date.now()) {\r\n        //         setIsMintLive(true);\r\n        //     }\r\n        // })\r\n\r\n        // getNFTData(wallet).then(nftData => {\r\n        //     setNftsData(nftData)\r\n        // })\r\n        \r\n        // getIsSoldOut(wallet).then(isSoldOut => {\r\n        //     setIsSoldOut(isSoldOut);\r\n        // })\r\n\r\n        // const isMinting = getIsMinting();\r\n        \r\n\r\n        // const [mintCount, setMintCount] = useState(5);\r\n        \r\n\r\n        return {\r\n            connected: wallet.connected,\r\n            wallet,\r\n            balance,\r\n            setBalance,\r\n            nftCount, setNftCount,\r\n            connection,\r\n            output, setOutput,\r\n            calculating, setCalculating\r\n            // getBalance,\r\n            // isMinting,\r\n            // mintStartDate,\r\n            // startMint,\r\n            // isSoldOut,\r\n            // startMintMultiple,\r\n            // useWalletNfts,\r\n            // nftsData,\r\n            // isLoading,\r\n            // nfts,\r\n            // isMintLive,\r\n            // setIsMintLive,\r\n            // mintCount,\r\n            // setMintCount\r\n        }\r\n    }\r\n});\r\n","import { render } from \"./Home.vue?vue&type=template&id=42f3ffc0&ts=true\"\nimport script from \"./Home.vue?vue&type=script&lang=ts\"\nexport * from \"./Home.vue?vue&type=script&lang=ts\"\n\nimport \"./Home.vue?vue&type=style&index=0&id=42f3ffc0&lang=css\"\n\nimport exportComponent from \"C:\\\\Users\\\\Lars\\\\github\\\\mrlion2\\\\node_modules\\\\vue-loader-v16\\\\dist\\\\exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['render',render]])\n\nexport default __exports__","\nimport { defineComponent } from 'vue';\nimport { WalletMultiButton, WalletModalProvider } from \"@solana/wallet-adapter-vue-ui\"\nimport { WalletProvider } from '@solana/wallet-adapter-vue'\nimport Home from './components/Home.vue';\nimport {\n    getPhantomWallet,\n    getLedgerWallet,\n    getMathWallet,\n    getSlopeWallet,\n    getSolflareWallet,\n    getSolflareWebWallet,\n    getSolletWallet,\n    getSolongWallet\n} from '@solana/wallet-adapter-wallets'\n\nexport default defineComponent({\n    name: 'App',\n    components: {\n        Home,\n        WalletProvider,\n        WalletModalProvider,\n        WalletMultiButton\n    },\n    setup() {\n        const wallets = [\n            getPhantomWallet(),\n            getLedgerWallet(),\n            getMathWallet(),\n            getMathWallet(),\n            getSlopeWallet(),\n            getSolflareWallet(),\n            getSolflareWebWallet(),\n            getSolletWallet(),\n            getSolongWallet()\n        ]\n        return {\n            wallets\n        }\n  }\n});\n","import { render } from \"./App.vue?vue&type=template&id=bf7dde22&ts=true\"\nimport script from \"./App.vue?vue&type=script&lang=ts\"\nexport * from \"./App.vue?vue&type=script&lang=ts\"\n\nimport \"./App.vue?vue&type=style&index=0&id=bf7dde22&lang=css\"\n\nimport exportComponent from \"C:\\\\Users\\\\Lars\\\\github\\\\mrlion2\\\\node_modules\\\\vue-loader-v16\\\\dist\\\\exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['render',render]])\n\nexport default __exports__","import { createApp } from 'vue'\nimport App from './App.vue'\n// import the styling for the toast\nimport 'mosha-vue-toastify/dist/style.css'\nconst app = createApp(App)\n\napp.mount('#app')\n","import {\r\n    Keypair,\r\n    Commitment,\r\n    Connection,\r\n    RpcResponseAndContext,\r\n    SignatureStatus,\r\n    SimulatedTransactionResponse,\r\n    Transaction,\r\n    TransactionInstruction,\r\n    TransactionSignature,\r\n    Blockhash,\r\n    FeeCalculator,\r\n    Signer\r\n  } from \"@solana/web3.js\";\r\n  \r\n  import { WalletNotConnectedError } from \"@solana/wallet-adapter-base\";\r\n  \r\n  interface BlockhashAndFeeCalculator {\r\n    blockhash: Blockhash;\r\n    feeCalculator: FeeCalculator;\r\n  }\r\n  \r\n  export const getErrorForTransaction = async (\r\n    connection: Connection,\r\n    txid: string\r\n  ) => {\r\n    // wait for all confirmation before geting transaction\r\n    await connection.confirmTransaction(txid, \"max\");\r\n  \r\n    const tx = await connection.getParsedConfirmedTransaction(txid);\r\n  \r\n    const errors: string[] = [];\r\n    if (tx?.meta && tx.meta.logMessages) {\r\n      tx.meta.logMessages.forEach((log) => {\r\n        const regex = /Error: (.*)/gm;\r\n        let m;\r\n        while ((m = regex.exec(log)) !== null) {\r\n          // This is necessary to avoid infinite loops with zero-width matches\r\n          if (m.index === regex.lastIndex) {\r\n            regex.lastIndex++;\r\n          }\r\n  \r\n          if (m.length > 1) {\r\n            errors.push(m[1]);\r\n          }\r\n        }\r\n      });\r\n    }\r\n  \r\n    return errors;\r\n  };\r\n  \r\n  export enum SequenceType {\r\n    Sequential,\r\n    Parallel,\r\n    StopOnFailure,\r\n  }\r\n  \r\n  export const sendTransactions = async (\r\n    connection: Connection,\r\n    wallet: any,\r\n    instructionSet: TransactionInstruction[][],\r\n    signersSet: Keypair[][],\r\n    sequenceType: SequenceType = SequenceType.Parallel,\r\n    commitment: Commitment = \"singleGossip\",\r\n    block?: BlockhashAndFeeCalculator\r\n  ): Promise<string[] | number> => {\r\n    if (!wallet.publicKey) throw new WalletNotConnectedError();\r\n  \r\n    const unsignedTxns: Transaction[] = [];\r\n  \r\n    if (!block) {\r\n      block = await connection.getRecentBlockhash(commitment);\r\n    }\r\n  \r\n    for (let i = 0; i < instructionSet.length; i++) {\r\n      const instructions = instructionSet[i];\r\n      const signers = signersSet[i];\r\n  \r\n      if (instructions.length === 0) {\r\n        continue;\r\n      }\r\n  \r\n      const transaction = new Transaction();\r\n      instructions.forEach((instruction) => transaction.add(instruction));\r\n      transaction.recentBlockhash = block.blockhash;\r\n      transaction.feePayer = wallet.publicKey\r\n      \r\n  \r\n      if (signers.length > 0) {\r\n        transaction.partialSign(\r\n          ...signers.map((s) => s as Signer)\r\n        );\r\n      }\r\n  \r\n      unsignedTxns.push(transaction);\r\n    }\r\n  \r\n    const signedTxns = await wallet.signAllTransactions(unsignedTxns);\r\n  \r\n    const pendingTxns: Promise<{ txid: string; slot: number }>[] = [];\r\n  \r\n    const breakEarlyObject = { breakEarly: false, i: 0 };\r\n    console.log(\r\n      \"Signed txns length\",\r\n      signedTxns.length,\r\n      \"vs handed in length\",\r\n      instructionSet.length\r\n    );\r\n  \r\n    const txIds = [];\r\n    for (let i = 0; i < signedTxns.length; i++) {\r\n      const signedTxnPromise = sendSignedTransaction({\r\n        connection,\r\n        signedTransaction: signedTxns[i],\r\n      });\r\n  \r\n      try {\r\n        const { txid } = await signedTxnPromise;\r\n        txIds.push(txid);\r\n      } catch (error) {\r\n        console.error(error);\r\n        // failCallback(signedTxns[i], i);\r\n        if (sequenceType === SequenceType.StopOnFailure) {\r\n          breakEarlyObject.breakEarly = true;\r\n          breakEarlyObject.i = i;\r\n        }\r\n      }\r\n  \r\n      if (sequenceType !== SequenceType.Parallel) {\r\n        try {\r\n          await signedTxnPromise;\r\n        } catch (e) {\r\n          console.log(\"Caught failure\", e);\r\n          if (breakEarlyObject.breakEarly) {\r\n            console.log(\"Died on \", breakEarlyObject.i);\r\n            return breakEarlyObject.i; // Return the txn we failed on by index\r\n          }\r\n        }\r\n      } else {\r\n        pendingTxns.push(signedTxnPromise);\r\n      }\r\n    }\r\n  \r\n    if (sequenceType !== SequenceType.Parallel) {\r\n      await Promise.all(pendingTxns);\r\n    }\r\n  \r\n    return txIds;\r\n  };\r\n  \r\n  export const sendTransaction = async (\r\n    connection: Connection,\r\n    wallet: any,\r\n    instructions: TransactionInstruction[],\r\n    signers: Keypair[],\r\n    awaitConfirmation = true,\r\n    commitment: Commitment = \"singleGossip\",\r\n    includesFeePayer: boolean,\r\n    block?: BlockhashAndFeeCalculator\r\n  ) => {\r\n    if (!wallet.publicKey) throw new WalletNotConnectedError();\r\n  \r\n    let transaction = new Transaction();\r\n    instructions.forEach((instruction) => transaction.add(instruction));\r\n    transaction.recentBlockhash = (\r\n      block || (await connection.getRecentBlockhash(commitment))\r\n    ).blockhash;\r\n  \r\n    if (includesFeePayer) {\r\n      transaction.setSigners(...signers.map((s) => s.publicKey));\r\n    } else {\r\n      transaction.setSigners(\r\n        // fee payed by the wallet owner\r\n        wallet.publicKey,\r\n        ...signers.map((s) => s.publicKey)\r\n      );\r\n    }\r\n  \r\n    if (signers.length > 0) {\r\n      transaction.partialSign(...signers);\r\n    }\r\n    if (!includesFeePayer) {\r\n      transaction = await wallet.signTransaction(transaction);\r\n    }\r\n  \r\n    const rawTransaction = transaction.serialize();\r\n    const options = {\r\n      skipPreflight: true,\r\n      commitment,\r\n    };\r\n  \r\n    const txid = await connection.sendRawTransaction(rawTransaction, options);\r\n    let slot = 0;\r\n  \r\n    if (awaitConfirmation) {\r\n      const confirmation = await awaitTransactionSignatureConfirmation(\r\n        txid,\r\n        DEFAULT_TIMEOUT,\r\n        connection,\r\n        commitment\r\n      );\r\n  \r\n      if (!confirmation)\r\n        throw new Error(\"Timed out awaiting confirmation on transaction\");\r\n      slot = confirmation?.slot || 0;\r\n  \r\n      if (confirmation?.err) {\r\n        const errors = await getErrorForTransaction(connection, txid);\r\n  \r\n        console.log(errors);\r\n        throw new Error(`Raw transaction ${txid} failed`);\r\n      }\r\n    }\r\n  \r\n    return { txid, slot };\r\n  };\r\n  \r\n  export const sendTransactionWithRetry = async (\r\n    connection: Connection,\r\n    wallet: any,\r\n    instructions: TransactionInstruction[],\r\n    signers: Keypair[],\r\n    commitment: Commitment = \"singleGossip\",\r\n    includesFeePayer: boolean,\r\n    block?: BlockhashAndFeeCalculator,\r\n    beforeSend?: () => void\r\n  ) => {\r\n    if (!wallet.publicKey) throw new WalletNotConnectedError();\r\n  \r\n    let transaction = new Transaction();\r\n    instructions.forEach((instruction) => transaction.add(instruction));\r\n    transaction.recentBlockhash = (\r\n      block || (await connection.getRecentBlockhash(commitment))\r\n    ).blockhash;\r\n  \r\n    if (includesFeePayer) {\r\n      transaction.setSigners(...signers.map((s) => s.publicKey));\r\n    } else {\r\n      transaction.setSigners(\r\n        // fee payed by the wallet owner\r\n        wallet.publicKey,\r\n        ...signers.map((s) => s.publicKey)\r\n      );\r\n    }\r\n  \r\n    if (signers.length > 0) {\r\n      transaction.partialSign(...signers);\r\n    }\r\n    if (!includesFeePayer) {\r\n      transaction = await wallet.signTransaction(transaction);\r\n    }\r\n  \r\n    if (beforeSend) {\r\n      beforeSend();\r\n    }\r\n  \r\n    const { txid, slot } = await sendSignedTransaction({\r\n      connection,\r\n      signedTransaction: transaction,\r\n    });\r\n  \r\n    return { txid, slot };\r\n  };\r\n  \r\n  export const getUnixTs = () => {\r\n    return new Date().getTime() / 1000;\r\n  };\r\n  \r\n  const DEFAULT_TIMEOUT = 15000;\r\n  \r\n  export async function sendSignedTransaction({\r\n    signedTransaction,\r\n    connection,\r\n    timeout = DEFAULT_TIMEOUT,\r\n  }: {\r\n    signedTransaction: Transaction;\r\n    connection: Connection;\r\n    sendingMessage?: string;\r\n    sentMessage?: string;\r\n    successMessage?: string;\r\n    timeout?: number;\r\n  }): Promise<{ txid: string; slot: number }> {\r\n    const rawTransaction = signedTransaction.serialize();\r\n    const startTime = getUnixTs();\r\n    let slot = 0;\r\n    const txid: TransactionSignature = await connection.sendRawTransaction(\r\n      rawTransaction,\r\n      {\r\n        skipPreflight: true,\r\n      }\r\n    );\r\n  \r\n    console.log(\"Started awaiting confirmation for\", txid);\r\n  \r\n    let done = false;\r\n    (async () => {\r\n      while (!done && getUnixTs() - startTime < timeout) {\r\n        connection.sendRawTransaction(rawTransaction, {\r\n          skipPreflight: true,\r\n        });\r\n        await sleep(500);\r\n      }\r\n    })();\r\n    try {\r\n      const confirmation = await awaitTransactionSignatureConfirmation(\r\n        txid,\r\n        timeout,\r\n        connection,\r\n        \"recent\",\r\n        true\r\n      );\r\n  \r\n      if (!confirmation)\r\n        throw new Error(\"Timed out awaiting confirmation on transaction\");\r\n  \r\n      if (confirmation.err) {\r\n        console.error(confirmation.err);\r\n        throw new Error(\"Transaction failed: Custom instruction error\");\r\n      }\r\n  \r\n      slot = confirmation?.slot || 0;\r\n    } catch (err: any) {\r\n      console.error(\"Timeout Error caught\", err);\r\n      if (err.timeout) {\r\n        throw new Error(\"Timed out awaiting confirmation on transaction\");\r\n      }\r\n      let simulateResult: SimulatedTransactionResponse | null = null;\r\n      simulateResult = (\r\n        await simulateTransaction(connection, signedTransaction, \"single\")\r\n      ).value;\r\n      if (simulateResult && simulateResult.err) {\r\n        if (simulateResult.logs) {\r\n          for (let i = simulateResult.logs.length - 1; i >= 0; --i) {\r\n            const line = simulateResult.logs[i];\r\n            if (line.startsWith(\"Program log: \")) {\r\n              throw new Error(\r\n                \"Transaction failed: \" + line.slice(\"Program log: \".length)\r\n              );\r\n            }\r\n          }\r\n        }\r\n        throw new Error(JSON.stringify(simulateResult.err));\r\n      }\r\n      // throw new Error('Transaction failed');\r\n    } finally {\r\n      done = true;\r\n    }\r\n  \r\n    console.log(\"Latency\", txid, getUnixTs() - startTime);\r\n    return { txid, slot };\r\n  }\r\n  \r\n  async function simulateTransaction(\r\n    connection: Connection,\r\n    transaction: Transaction,\r\n    commitment: Commitment\r\n  ): Promise<RpcResponseAndContext<SimulatedTransactionResponse>> {\r\n    transaction.recentBlockhash = await (connection as any)._recentBlockhash(\r\n      (connection as any)._disableBlockhashCaching\r\n    );\r\n  \r\n    const signData = transaction.serializeMessage();\r\n    const wireTransaction = (transaction as any)._serialize(signData);\r\n    const encodedTransaction = wireTransaction.toString(\"base64\");\r\n    const config: any = { encoding: \"base64\", commitment };\r\n    const args = [encodedTransaction, config];\r\n  \r\n    const res = await (connection as any)._rpcRequest(\"simulateTransaction\", args);\r\n    if (res.error) {\r\n      throw new Error(\"failed to simulate transaction: \" + res.error.message);\r\n    }\r\n    return res.result;\r\n  }\r\n  \r\n  async function awaitTransactionSignatureConfirmation(\r\n    txid: TransactionSignature,\r\n    timeout: number,\r\n    connection: Connection,\r\n    commitment: Commitment = \"recent\",\r\n    queryStatus = false\r\n  ): Promise<SignatureStatus | null | void> {\r\n    let done = false;\r\n    let status: SignatureStatus | null | void = {\r\n      slot: 0,\r\n      confirmations: 0,\r\n      err: null,\r\n    };\r\n    let subId = 0;\r\n    status = await new Promise( (resolve, reject) => {\r\n      setTimeout(() => {\r\n        if (done) {\r\n          return;\r\n        }\r\n        done = true;\r\n        console.log(\"Rejecting for timeout...\");\r\n        reject({ timeout: true });\r\n      }, timeout);\r\n      try {\r\n        subId = connection.onSignature(\r\n          txid,\r\n          (result, context) => {\r\n            done = true;\r\n            status = {\r\n              err: result.err,\r\n              slot: context.slot,\r\n              confirmations: 0,\r\n            };\r\n            if (result.err) {\r\n              console.log(\"Rejected via websocket\", result.err);\r\n              reject(status);\r\n            } else {\r\n              console.log(\"Resolved via websocket\", result);\r\n              resolve(status);\r\n            }\r\n          },\r\n          commitment\r\n        );\r\n      } catch (e) {\r\n        done = true;\r\n        console.error(\"WS error in setup\", txid, e);\r\n      }\r\n      while (!done && queryStatus) {\r\n        // eslint-disable-next-line no-loop-func\r\n        (async () => {\r\n          try {\r\n            const signatureStatuses = await connection.getSignatureStatuses([\r\n              txid,\r\n            ]);\r\n            status = signatureStatuses && signatureStatuses.value[0];\r\n            if (!done) {\r\n              if (!status) {\r\n                console.log(\"REST null result for\", txid, status);\r\n              } else if (status.err) {\r\n                console.log(\"REST error for\", txid, status);\r\n                done = true;\r\n                reject(status.err);\r\n              } else if (!status.confirmations) {\r\n                console.log(\"REST no confirmations for\", txid, status);\r\n              } else {\r\n                console.log(\"REST confirmation for\", txid, status);\r\n                done = true;\r\n                resolve(status);\r\n              }\r\n            }\r\n          } catch (e) {\r\n            if (!done) {\r\n              console.log(\"REST connection error: txid\", txid, e);\r\n            }\r\n          }\r\n        })();\r\n        sleep(2000);\r\n      }\r\n    });\r\n  \r\n    if ((connection as any)._signatureSubscriptions[subId])\r\n      connection.removeSignatureListener(subId);\r\n    done = true;\r\n    console.log(\"Returning status\", status);\r\n    return status;\r\n  }\r\n  \r\n  export const sleep = (ms: number): Promise<void> => {\r\n    return new Promise((resolve) => setTimeout(resolve, ms));\r\n  };\r\n  "],"sourceRoot":""}